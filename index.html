<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Fractured Engine</title>
  <style>
    * {
      box-sizing: border-box;
    }

    body {
      background: #050509;
      color: #f5f5f5;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: stretch;
      justify-content: flex-start;
    }

    /* Resource bar at top */
    #resourceBar {
      width: 100%;
      padding: 8px 16px;
      background: #080810;
      border-bottom: 1px solid #222233;
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 18px;
      font-size: 14px;
    }

    .res-item {
      display: flex;
      align-items: baseline;
      gap: 6px;
    }

    .res-icon {
      font-size: 18px;
      opacity: 0.9;
    }

    .res-value {
      font-variant-numeric: tabular-nums;
      min-width: 80px;
      text-align: right;
    }

    .res-label {
      font-size: 11px;
      opacity: 0.7;
    }

    /* Main centered content */
    #gameRoot {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 16px;
    }

    #gameInner {
      max-width: 900px;
      width: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 16px;
      text-align: center;
    }

    h1 {
      font-size: 18px;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      margin: 4px 0 2px 0;
      opacity: 0.9;
    }

    #subtitle {
      font-size: 11px;
      opacity: 0.7;
      margin-bottom: 0;
    }

    .panel {
      border-radius: 8px;
      border: 1px solid #262638;
      background: #10101a;
      padding: 10px 12px;
      width: 100%;
      text-align: left;
    }

    .panel-title {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 4px;
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      opacity: 0.85;
    }

    .panel-title span.icon {
      font-size: 16px;
      margin-right: 4px;
    }

    .panel-flavor {
      font-size: 11px;
      opacity: 0.7;
      margin-bottom: 8px;
    }

    .row {
      margin-bottom: 6px;
      font-size: 12px;
    }

    .small {
      font-size: 11px;
      opacity: 0.8;
    }

    button {
      padding: 6px 10px;
      margin: 4px 4px 0 0;
      background: #151524;
      border: 1px solid #3b3b55;
      color: #f5f5f5;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      transition: transform 0.05s ease-out, border-color 0.12s ease-out, box-shadow 0.12s ease-out;
    }

    button:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.45);
    }

    button:disabled {
      opacity: 0.4;
      cursor: default;
      box-shadow: none;
    }

    .affordable {
      border-color: #9caeff;
    }

    .inline-stat {
      font-variant-numeric: tabular-nums;
    }

    .hidden {
      display: none !important;
    }

    /* Layout: 2-column for Sparks tab on larger screens */
    #sparksLayout {
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px;
      width: 100%;
    }

    @media (min-width: 900px) {
      #sparksLayout {
        grid-template-columns: minmax(0, 1.6fr) minmax(0, 1.2fr);
      }
    }

    /* Generators */
    .gen-row {
      border-top: 1px solid #262638;
      padding-top: 6px;
      margin-top: 6px;
    }

    .gen-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      font-size: 12px;
      margin-bottom: 3px;
    }

    .gen-left {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .gen-icon {
      font-size: 16px;
      opacity: 0.9;
    }

    .gen-name {
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
    }

    .gen-count {
      font-size: 11px;
      opacity: 0.8;
    }

    .gen-body {
      margin-bottom: 3px;
    }

    .gen-flavor {
      font-size: 10px;
      opacity: 0.7;
      margin-bottom: 4px;
    }

    .gen-actions {
      display: flex;
      justify-content: flex-start;
      flex-wrap: wrap;
    }

    /* Intro overlay */
    #introOverlay {
      position: fixed;
      inset: 0;
      background: rgba(2, 2, 8, 0.9);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    #introModal {
      width: 90%;
      max-width: 480px;
      background: #10101a;
      border-radius: 10px;
      border: 1px solid #3b3b55;
      padding: 16px 18px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.8);
      text-align: left;
    }

    #introTitle {
      font-size: 16px;
      text-transform: uppercase;
      letter-spacing: 0.15em;
      margin-bottom: 6px;
    }

    #introBody {
      font-size: 12px;
      line-height: 1.5;
      opacity: 0.9;
      margin-bottom: 10px;
    }

    #introHint {
      font-size: 11px;
      opacity: 0.7;
      margin-bottom: 10px;
    }

    #introModal button {
      width: 100%;
      margin-top: 4px;
    }

    /* Nav bar at bottom */
    #navBar {
      margin-top: 4px;
      display: flex;
      justify-content: center;
      gap: 8px;
    }

    .nav-btn {
      padding: 6px 14px;
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      background: #0b0b14;
    }

    .nav-btn.active {
      border-color: #9caeff;
      background: #181826;
    }

    /* Upgrades */
    .upgrade-section-title {
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.09em;
      opacity: 0.8;
      margin: 6px 0 4px 0;
    }

    .upgrade-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-bottom: 6px;
    }

    .upgrade-icon-btn {
      width: 30px;
      height: 30px;
      border-radius: 4px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      padding: 0;
      margin: 0;
      background: #151524;
    }

    .upgrade-icon-btn.purchased {
      opacity: 0.45;
      border-color: #50506a;
    }

    #upgradeDetails {
      margin-top: 6px;
      border-top: 1px solid #262638;
      padding-top: 6px;
      min-height: 60px;
    }

    #upgradeDetailsTitle {
      font-size: 12px;
      font-weight: 600;
      margin-bottom: 2px;
    }

    #upgradeDetailsFlavor {
      font-size: 11px;
      opacity: 0.75;
      margin-bottom: 4px;
    }

    #upgradeDetailsEffect,
    #upgradeDetailsCost,
    #upgradeDetailsCurrent {
      font-size: 11px;
      margin-bottom: 2px;
    }

    /* Settings */
    .settings-row {
      font-size: 12px;
      margin-bottom: 8px;
    }

    .settings-row label {
      cursor: pointer;
    }

    #notationSelect {
      background: #151524;
      border: 1px solid #3b3b55;
      color: #f5f5f5;
      border-radius: 4px;
      padding: 3px 6px;
      font-size: 12px;
    }

    .settings-buttons {
      margin-top: 6px;
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    @media (max-width: 600px) {
      #gameInner {
        max-width: 100%;
      }

      .panel {
        max-width: 100%;
      }

      #resourceBar {
        font-size: 12px;
        gap: 10px;
      }

      .res-value {
        min-width: 70px;
      }
    }
  </style>
</head>
<body>
  <!-- Intro overlay (first time only) -->
  <div id="introOverlay" class="hidden">
    <div id="introModal">
      <div id="introTitle">Fractured Engine</div>
      <div id="introBody">
        The core that once held reality together has shattered.
        Its routines are gone, leaving only drifting Sparks in the dark.
        You are the new Architect, rebuilding from nothing by stitching together
        crude constructs until the engine remembers how to run itself.
      </div>
      <div id="introHint">
        Your work begins with simple generators.
        As the engine strengthens, deeper systems will reveal themselves.
      </div>
      <button id="introConfirmBtn">Begin reassembly</button>
    </div>
  </div>

  <!-- Resource bar -->
  <div id="resourceBar">
    <div class="res-item">
      <span class="res-icon">●</span>
      <span class="res-value inline-stat" id="sparksDisplay">0</span>
      <span class="res-label">Sparks</span>
    </div>
    <div class="res-item">
      <span class="res-icon">⌘</span>
      <span class="res-value inline-stat" id="stabilizersDisplay">0</span>
      <span class="res-label">Stabilizers</span>
    </div>
    <div class="res-item">
      <span class="res-icon">✶</span>
      <span class="res-value inline-stat" id="spsDisplay">0</span>
      <span class="res-label">Sparks per second</span>
    </div>
  </div>

  <!-- Main content -->
  <div id="gameRoot">
    <div id="gameInner">
      <div>
        <h1>Fractured Engine</h1>
        <div id="subtitle">Prototype build - let the engine run itself</div>
      </div>

      <!-- Sparks tab content -->
      <div id="tabSparks">
        <div id="sparksLayout">
          <!-- Generators panel -->
          <div class="panel" id="panelGenerators">
            <div class="panel-title">
              <span><span class="icon">◆</span> Sparks Lattice</span>
            </div>
            <div class="panel-flavor">
              The first layer of the new engine. Simple constructs that coax Sparks into motion.
            </div>
            <div class="row small">
              Generators produce Sparks automatically. Higher constructs unlock as the lattice grows.
            </div>
            <div id="generatorsList"></div>
          </div>

          <!-- Stabilize panel (prestige) -->
          <div class="panel hidden" id="panelStabilize">
            <div class="panel-title">
              <span><span class="icon">⌘</span> Stabilization Cycle</span>
            </div>
            <div class="panel-flavor">
              Collapse this run into a cleaner pattern and store what the engine learned as Stabilizers.
            </div>
            <div class="row small">
              Resets Sparks, generators, and Spark-layer upgrades. Stabilizer upgrades persist.
            </div>
            <div class="row small">
              Raw progress toward next Stabilizer:
              <span id="stabilizeProgress" class="inline-stat">0.00</span>
            </div>
            <div class="row small">
              Actual yield on stabilize:
              <span id="stabilizePreview" class="inline-stat">0</span> Stabilizers
              (run total <span id="runTotalSparks" class="inline-stat">0</span> Sparks)
            </div>
            <button id="stabilizeBtn">Stabilize Flow</button>
          </div>
        </div>
      </div>

      <!-- Upgrades tab content -->
      <div id="tabUpgrades" class="hidden">
        <div class="panel" id="panelUpgrades">
          <div class="panel-title">
            <span><span class="icon">✦</span> Engine Upgrades</span>
          </div>
          <div class="panel-flavor">
            Small adjustments in the lattice shift how every construct behaves.
            Upgrades here set the tone for the entire run.
          </div>

          <!-- Spark upgrades -->
          <div class="upgrade-section">
            <div class="upgrade-section-title">Spark Upgrades</div>
            <div class="row small">
              Purchased Spark upgrades are lost when you stabilize, unless you unlock persistence.
            </div>
            <div class="upgrade-grid" id="sparkUpgradesGrid"></div>
          </div>

          <!-- Stabilizer upgrades -->
          <div class="upgrade-section">
            <div class="upgrade-section-title">Stabilizer Upgrades</div>
            <div class="row small">
              Stabilizer upgrades persist through stabilizations.
            </div>
            <div class="upgrade-grid" id="stabUpgradesGrid"></div>
          </div>

          <!-- Details for hovered/selected upgrade -->
          <div id="upgradeDetails">
            <div id="upgradeDetailsTitle">Hover or tap an upgrade icon.</div>
            <div id="upgradeDetailsFlavor"></div>
            <div id="upgradeDetailsEffect"></div>
            <div id="upgradeDetailsCost"></div>
            <div id="upgradeDetailsCurrent"></div>
          </div>
        </div>
      </div>

      <!-- Settings tab content -->
      <div id="tabSettings" class="hidden">
        <div class="panel" id="panelSettings">
          <div class="panel-title">
            <span><span class="icon">☰</span> Settings</span>
          </div>
          <div class="panel-flavor small">
            Adjust how the engine presents itself. Changes are stored in your local save.
          </div>

          <div class="settings-row">
            <label>
              <input type="checkbox" id="setting_autosave">
              Enable autosave (periodically saves in the background)
            </label>
          </div>

          <div class="settings-row">
            <span class="small">Number notation:</span><br>
            <select id="notationSelect">
              <option value="short">Short (1.23K)</option>
              <option value="scientific">Scientific (1.23e3)</option>
            </select>
          </div>

          <div class="settings-buttons">
            <button id="btnSaveNow">Save now</button>
            <button id="btnShowIntro">Show intro again next load</button>
            <button id="btnFullReset">Reset all progress</button>
          </div>
        </div>
      </div>

      <!-- Nav bar -->
      <div id="navBar">
        <button class="nav-btn active" data-tab="sparks">Sparks</button>
        <button class="nav-btn" data-tab="upgrades">Upgrades</button>
        <button class="nav-btn" data-tab="settings">Settings</button>
      </div>
    </div>
  </div>

  <script>
    // ---------- CONFIG ----------

    const SAVE_KEY = "fracturedEngineSave_v4";
    const INTRO_KEY = "fracturedEngineIntroSeen";

    const generators = [
      {
        id: "g1",
        name: "Ember Conduits",
        shortLabel: "Conduit",
        icon: "◆",
        baseRate: 1.0,
        baseCost: 8,
        costGrowth: 1.13,
        unlockAtSparks: 0,
        flavor: "Thin channels that keep loose Sparks from leaking at bends."
      },
      {
        id: "g2",
        name: "Pulse Relays",
        shortLabel: "Relay",
        icon: "▶",
        baseRate: 6,
        baseCost: 60,
        costGrowth: 1.14,
        unlockAtSparks: 40,
        flavor: "Rhythmic arrays that turn static flows into steady pulses."
      },
      {
        id: "g3",
        name: "Flux Weavers",
        shortLabel: "Weaver",
        icon: "✺",
        baseRate: 30,
        baseCost: 320,
        costGrowth: 1.16,
        unlockAtSparks: 180,
        flavor: "Weave multiple streams of Sparks into a coherent current."
      },
      {
        id: "g4",
        name: "Core Looms",
        shortLabel: "Loom",
        icon: "▣",
        baseRate: 120,
        baseCost: 1400,
        costGrowth: 1.18,
        unlockAtSparks: 800,
        flavor: "Massive frames that spin Sparks into dense, reusable patterns."
      },
      {
        id: "g5",
        name: "Singularity Seeds",
        shortLabel: "Seed",
        icon: "◎",
        baseRate: 500,
        baseCost: 4800,
        costGrowth: 1.2,
        unlockAtSparks: 2600,
        flavor: "Proto cores that bend local rules, feeding on their own output."
      }
    ];

    // Spark upgrades (reset on stabilize unless persistence unlocked)
    const sparkUpgrades = [
      {
        id: "u_spark_conduit_double",
        name: "Reinforced Channels",
        icon: "▴",
        currency: "sparks",
        cost: 120,
        flavor: "Add extra plating where the first conduits twist and strain.",
        effectText: "Doubles the production of Ember Conduits.",
        type: "mult_gen_rate",
        targetGenIndex: 0,
        value: 2
      },
      {
        id: "u_spark_conduit_scaling",
        name: "Smoothed Pathways",
        icon: "▤",
        currency: "sparks",
        cost: 260,
        flavor: "Flow-friendly layouts that keep cost pressure from spiking.",
        effectText: "Reduces Ember Conduit cost scaling.",
        type: "reduce_cost_growth",
        targetGenIndex: 0,
        value: 0.04
      },
      {
        id: "u_spark_echoes",
        name: "Residual Echoes",
        icon: "◌",
        currency: "sparks",
        cost: 520,
        flavor: "Each idle Spark hums softly, adding to the background rhythm.",
        effectText: "Boosts all Spark production based on unspent Sparks.",
        type: "global_dep_boost"
      },
      {
        id: "u_spark_relay_double",
        name: "Relay Overclock",
        icon: "▹",
        currency: "sparks",
        cost: 900,
        flavor: "The relays twitch faster than the eye can track.",
        effectText: "Doubles the production of Pulse Relays.",
        type: "mult_gen_rate",
        targetGenIndex: 1,
        value: 2
      },
      {
        id: "u_spark_weaver_double",
        name: "Weaver Synchrony",
        icon: "✹",
        currency: "sparks",
        cost: 2200,
        flavor: "Weavers align their loops so no energy slips through the gaps.",
        effectText: "Doubles the production of Flux Weavers.",
        type: "mult_gen_rate",
        targetGenIndex: 2,
        value: 2
      },
      {
        id: "u_spark_lattice_focus",
        name: "Lattice Focus",
        icon: "◇",
        currency: "sparks",
        cost: 6000,
        flavor: "Tightens every joint in the lattice, pushing more power through each link.",
        effectText: "Boosts all generator output based on the number of different generator types you own.",
        type: "global_type_boost"
      }
    ];

    // Stabilizer upgrades (permanent)
    const stabUpgrades = [
      {
        id: "u_stab_resonant_coils",
        name: "Resonant Coils",
        icon: "✶",
        currency: "stabilizers",
        cost: 1,
        flavor: "Tune the core frequency so that every construct vibrates in phase.",
        effectText: "Increases all Spark production by x1.5 permanently.",
        type: "global_mult",
        value: 1.5
      },
      {
        id: "u_stab_deep_memory",
        name: "Deep Memory",
        icon: "⌘",
        currency: "stabilizers",
        cost: 3,
        flavor: "Etch each run deeper into the engine's memory banks.",
        effectText: "Increases Stabilizer gain from each run.",
        type: "prestige_gain_mult",
        value: 1.5
      },
      {
        id: "u_stab_persistent_lattice",
        name: "Persistent Lattice",
        icon: "▣",
        currency: "stabilizers",
        cost: 5,
        flavor: "Lock the lattice pattern so its clever tricks survive collapse.",
        effectText: "Spark upgrades are no longer reset when you stabilize.",
        type: "keep_spark_upgrades"
      }
    ];

    // ---------- STATE ----------

    const state = {
      sparks: 0,
      stabilizers: 0,
      sparkMultiplier: 1,          // from stabilizer global_mult upgrades
      stabilizerGainMult: 1,       // from Deep Memory
      totalSparksThisRun: 0,
      genCounts: new Array(generators.length).fill(0),
      upgrades: {
        sparks: {},
        stabilizers: {}
      },
      settings: {
        autosave: true,
        notation: "short"
      }
    };

    let selectedUpgrade = null;

    // ---------- UTILS ----------

    function formatNumber(x) {
      const notation = state.settings?.notation || "short";
      if (notation === "scientific" && x >= 1000) {
        return x.toExponential(2);
      }
      // short notation
      if (x >= 1e9) return x.toExponential(2);
      if (x >= 1e6) return (x / 1e6).toFixed(2) + "M";
      if (x >= 1e3) return (x / 1e3).toFixed(2) + "K";
      return x.toFixed(2);
    }

    function formatSmall(x) {
      if (x >= 100) return x.toFixed(0);
      if (x >= 10) return x.toFixed(1);
      return x.toFixed(2);
    }

    function isUpgradePurchased(type, id) {
      return !!state.upgrades[type][id];
    }

    function effectiveCostGrowth(index) {
      const gen = generators[index];
      let g = gen.costGrowth;
      if (isUpgradePurchased("sparks", "u_spark_conduit_scaling") && index === 0) {
        g = Math.max(1.02, g - 0.04);
      }
      return g;
    }

    function genCost(index) {
      const gen = generators[index];
      const growth = effectiveCostGrowth(index);
      return gen.baseCost * Math.pow(growth, state.genCounts[index]);
    }

    function generatorRateMultiplier(index) {
      let mult = 1;

      // Per-generator doubles
      if (isUpgradePurchased("sparks", "u_spark_conduit_double") && index === 0) {
        mult *= 2;
      }
      if (isUpgradePurchased("sparks", "u_spark_relay_double") && index === 1) {
        mult *= 2;
      }
      if (isUpgradePurchased("sparks", "u_spark_weaver_double") && index === 2) {
        mult *= 2;
      }

      // Dependent global boost based on unspent Sparks
      if (isUpgradePurchased("sparks", "u_spark_echoes")) {
        const extra = 1 + Math.log10(1 + state.sparks) / 4;
        mult *= extra;
      }

      // Global type-based boost
      if (isUpgradePurchased("sparks", "u_spark_lattice_focus")) {
        let typesOwned = 0;
        for (let i = 0; i < generators.length; i++) {
          if (state.genCounts[i] > 0) typesOwned += 1;
        }
        const typeFactor = 1 + typesOwned * 0.25;
        mult *= typeFactor;
      }

      return mult;
    }

    function genEffectiveRate(index) {
      const base = generators[index].baseRate;
      return base * generatorRateMultiplier(index);
    }

    function sparksPerSecond() {
      let total = 0;
      generators.forEach((gen, index) => {
        total += state.genCounts[index] * genEffectiveRate(index);
      });
      return total * state.sparkMultiplier;
    }

    function stabilizerRawGain() {
      // Gentler formula, shows progress as decimal
      const base = Math.pow(state.totalSparksThisRun, 0.6) / 50;
      return base * state.stabilizerGainMult;
    }

    function stabilizerGainFloored() {
      return Math.floor(stabilizerRawGain());
    }

    // ---------- CORE LOGIC ----------

    function gainSparks(amount) {
      state.sparks += amount;
      state.totalSparksThisRun += amount;
    }

    function tick(dt) {
      const sps = sparksPerSecond();
      gainSparks(sps * dt);
    }

    function resetSparkLayer() {
      state.sparks = 0;
      state.totalSparksThisRun = 0;
      state.genCounts = new Array(generators.length).fill(0);

      // Reset Spark upgrades unless we have Persistent Lattice
      if (!isUpgradePurchased("stabilizers", "u_stab_persistent_lattice")) {
        state.upgrades.sparks = {};
      }
    }

    function stabilize() {
      const gainInt = stabilizerGainFloored();
      if (gainInt <= 0) return;
      state.stabilizers += gainInt;
      resetSparkLayer();
      saveGame();
    }

    // ---------- UI BUILD ----------

    function buildGeneratorUI() {
      const list = document.getElementById("generatorsList");
      list.innerHTML = "";

      generators.forEach((gen, index) => {
        const row = document.createElement("div");
        row.className = "gen-row hidden";
        row.id = "genRow_" + gen.id;

        row.innerHTML = `
          <div class="gen-header">
            <div class="gen-left">
              <span class="gen-icon">${gen.icon}</span>
              <span class="gen-name">${gen.name}</span>
            </div>
            <div class="gen-count">
              Owned: <span id="genCount_${gen.id}" class="inline-stat">0</span>
            </div>
          </div>
          <div class="gen-body small">
            Produces <span class="inline-stat">${gen.baseRate.toFixed(2)}</span> Sparks per second each
            before upgrades.<br>
            Cost: <span id="genCost_${gen.id}" class="inline-stat">${formatNumber(gen.baseCost)}</span> Sparks
          </div>
          <div class="gen-flavor">
            ${gen.flavor}
          </div>
          <div class="gen-actions">
            <button id="genBuy_${gen.id}">Construct ${gen.shortLabel}</button>
          </div>
        `;
        list.appendChild(row);
      });
    }

    function buildUpgradesUI() {
      const sparkGrid = document.getElementById("sparkUpgradesGrid");
      const stabGrid = document.getElementById("stabUpgradesGrid");
      sparkGrid.innerHTML = "";
      stabGrid.innerHTML = "";

      sparkUpgrades.forEach(upg => {
        const btn = document.createElement("button");
        btn.className = "upgrade-icon-btn";
        btn.id = "upgBtn_sparks_" + upg.id;
        btn.textContent = upg.icon;
        btn.dataset.type = "sparks";
        btn.dataset.id = upg.id;
        sparkGrid.appendChild(btn);
      });

      stabUpgrades.forEach(upg => {
        const btn = document.createElement("button");
        btn.className = "upgrade-icon-btn";
        btn.id = "upgBtn_stab_" + upg.id;
        btn.textContent = upg.icon;
        btn.dataset.type = "stabilizers";
        btn.dataset.id = upg.id;
        stabGrid.appendChild(btn);
      });
    }

    // ---------- VISIBILITY & HIGHLIGHTS ----------

    function updateVisibility() {
      // Generators unlock with progress
      generators.forEach((gen, index) => {
        const row = document.getElementById("genRow_" + gen.id);
        if (!row) return;

        const unlocked = state.totalSparksThisRun >= gen.unlockAtSparks || state.genCounts[index] > 0;
        if (unlocked) {
          row.classList.remove("hidden");
        }
      });

      let activeGenTypes = 0;
      generators.forEach((_, index) => {
        if (state.genCounts[index] > 0) activeGenTypes += 1;
      });

      const panelStabilize = document.getElementById("panelStabilize");
      const canSeePrestige =
        activeGenTypes >= 2 || state.totalSparksThisRun >= 800 || state.stabilizers > 0;

      if (canSeePrestige) {
        panelStabilize.classList.remove("hidden");
      }
    }

    function toggleAffordable(element, canAfford) {
      if (!element) return;
      if (canAfford) {
        element.classList.add("affordable");
      } else {
        element.classList.remove("affordable");
      }
    }

    // ---------- UPGRADES LOGIC ----------

    function getUpgradeDef(type, id) {
      if (type === "sparks") {
        return sparkUpgrades.find(u => u.id === id) || null;
      }
      if (type === "stabilizers") {
        return stabUpgrades.find(u => u.id === id) || null;
      }
      return null;
    }

    function canAffordUpgrade(upg) {
      if (upg.currency === "sparks") return state.sparks >= upg.cost;
      if (upg.currency === "stabilizers") return state.stabilizers >= upg.cost;
      return false;
    }

    function buyUpgrade(type, id) {
      if (isUpgradePurchased(type, id)) return;
      const upg = getUpgradeDef(type, id);
      if (!upg) return;
      if (!canAffordUpgrade(upg)) return;

      if (upg.currency === "sparks") state.sparks -= upg.cost;
      if (upg.currency === "stabilizers") state.stabilizers -= upg.cost;

      state.upgrades[type][id] = true;

      // Apply immediate permanent effects
      if (type === "stabilizers") {
        if (upg.type === "global_mult") {
          state.sparkMultiplier *= upg.value;
        }
        if (upg.type === "prestige_gain_mult") {
          state.stabilizerGainMult *= upg.value;
        }
        // keep_spark_upgrades is handled in resetSparkLayer
      }

      saveGame();
    }

    function updateUpgradeButtonsUI() {
      sparkUpgrades.forEach(upg => {
        const btn = document.getElementById("upgBtn_sparks_" + upg.id);
        if (!btn) return;

        const purchased = isUpgradePurchased("sparks", upg.id);
        const affordable = canAffordUpgrade(upg);

        btn.classList.remove("purchased", "affordable");
        if (purchased) {
          btn.classList.add("purchased");
          btn.disabled = true;
        } else {
          btn.disabled = false;
          if (affordable) {
            btn.classList.add("affordable");
          }
        }
      });

      stabUpgrades.forEach(upg => {
        const btn = document.getElementById("upgBtn_stab_" + upg.id);
        if (!btn) return;

        const purchased = isUpgradePurchased("stabilizers", upg.id);
        const affordable = canAffordUpgrade(upg);

        btn.classList.remove("purchased", "affordable");
        if (purchased) {
          btn.classList.add("purchased");
          btn.disabled = true;
        } else {
          btn.disabled = false;
          if (affordable) {
            btn.classList.add("affordable");
          }
        }
      });
    }

    function describeCurrentEffect(upg) {
      if (upg.type === "global_dep_boost") {
        const extra = 1 + Math.log10(1 + state.sparks) / 4;
        if (isUpgradePurchased("sparks", upg.id)) {
          return "Current effect: global Spark production x" + extra.toFixed(2) + " based on unspent Sparks.";
        }
        return "If purchased now: global Spark production would be x" + extra.toFixed(2) + " based on unspent Sparks.";
      }
      if (upg.type === "mult_gen_rate" && isUpgradePurchased("sparks", upg.id)) {
        if (upg.targetGenIndex === 0) return "Current effect: Ember Conduits production x2.00.";
        if (upg.targetGenIndex === 1) return "Current effect: Pulse Relays production x2.00.";
        if (upg.targetGenIndex === 2) return "Current effect: Flux Weavers production x2.00.";
      }
      if (upg.type === "reduce_cost_growth" && isUpgradePurchased("sparks", upg.id)) {
        return "Current effect: Ember Conduit cost scaling reduced.";
      }
      if (upg.type === "global_type_boost") {
        let typesOwned = 0;
        for (let i = 0; i < generators.length; i++) {
          if (state.genCounts[i] > 0) typesOwned += 1;
        }
        const typeFactor = 1 + typesOwned * 0.25;
        if (isUpgradePurchased("sparks", upg.id)) {
          return "Current effect: all generators boosted x" + typeFactor.toFixed(2) +
            " from " + typesOwned + " active generator types.";
        }
        return "If purchased now: all generators would be boosted based on how many types you own (currently " +
          typesOwned + ").";
      }
      if (upg.type === "global_mult" && isUpgradePurchased("stabilizers", upg.id)) {
        return "Current effect: Spark production permanently multiplied by " + upg.value.toFixed(2) + ".";
      }
      if (upg.type === "prestige_gain_mult" && isUpgradePurchased("stabilizers", upg.id)) {
        return "Current effect: Stabilizer gain multiplied by " + upg.value.toFixed(2) + ".";
      }
      if (upg.type === "keep_spark_upgrades" && isUpgradePurchased("stabilizers", upg.id)) {
        return "Current effect: Spark upgrades are preserved when you stabilize.";
      }
      return "";
    }

    function updateUpgradeDetails() {
      const titleEl = document.getElementById("upgradeDetailsTitle");
      const flavorEl = document.getElementById("upgradeDetailsFlavor");
      const effectEl = document.getElementById("upgradeDetailsEffect");
      const costEl = document.getElementById("upgradeDetailsCost");
      const currentEl = document.getElementById("upgradeDetailsCurrent");

      if (!selectedUpgrade) {
        titleEl.textContent = "Hover or tap an upgrade icon.";
        flavorEl.textContent = "";
        effectEl.textContent = "";
        costEl.textContent = "";
        currentEl.textContent = "";
        return;
      }

      const { type, def } = selectedUpgrade;
      const purchased = isUpgradePurchased(type, def.id);
      const affordable = canAffordUpgrade(def);

      titleEl.textContent = def.name + (purchased ? " (purchased)" : "");
      flavorEl.textContent = def.flavor;
      effectEl.textContent = "Effect: " + def.effectText;

      const costText =
        def.currency === "sparks"
          ? formatNumber(def.cost) + " Sparks"
          : formatNumber(def.cost) + " Stabilizers";

      costEl.textContent = "Cost: " + costText + (affordable && !purchased ? " - affordable now." : "");
      currentEl.textContent = describeCurrentEffect(def);
    }

    // ---------- UI UPDATE ----------

    function updateUI() {
      document.getElementById("sparksDisplay").textContent = formatNumber(state.sparks);
      document.getElementById("stabilizersDisplay").textContent = formatNumber(state.stabilizers);
      document.getElementById("spsDisplay").textContent = formatNumber(sparksPerSecond());

      generators.forEach((gen, index) => {
        const countSpan = document.getElementById("genCount_" + gen.id);
        const costSpan = document.getElementById("genCost_" + gen.id);
        const button = document.getElementById("genBuy_" + gen.id);
        if (!countSpan || !costSpan || !button) return;

        const cost = genCost(index);
        countSpan.textContent = state.genCounts[index].toString();
        costSpan.textContent = formatNumber(cost);

        const canAfford = state.sparks >= cost;
        toggleAffordable(button, canAfford);
      });

      const raw = stabilizerRawGain();
      const floored = stabilizerGainFloored();
      document.getElementById("stabilizeProgress").textContent = formatSmall(raw);
      document.getElementById("stabilizePreview").textContent = floored.toString();
      document.getElementById("runTotalSparks").textContent = formatNumber(state.totalSparksThisRun);

      const stabilizeBtn = document.getElementById("stabilizeBtn");
      const canStabilizeNow = floored > 0;
      toggleAffordable(stabilizeBtn, canStabilizeNow);
      stabilizeBtn.disabled = !canStabilizeNow;

      updateUpgradeButtonsUI();
      updateUpgradeDetails();
      updateSettingsUIFromState();

      updateVisibility();
    }

    // ---------- SAVE / LOAD ----------

    function saveGame() {
      const saveData = JSON.stringify(state);
      localStorage.setItem(SAVE_KEY, saveData);
    }

    function loadGame() {
      const raw = localStorage.getItem(SAVE_KEY);
      if (!raw) return false;
      try {
        const data = JSON.parse(raw);

        state.sparks = data.sparks ?? 0;
        state.stabilizers = data.stabilizers ?? 0;
        state.sparkMultiplier = data.sparkMultiplier ?? 1;
        state.stabilizerGainMult = data.stabilizerGainMult ?? 1;
        state.totalSparksThisRun = data.totalSparksThisRun ?? 0;

        if (Array.isArray(data.genCounts)) {
          state.genCounts = data.genCounts.slice(0, generators.length);
          while (state.genCounts.length < generators.length) state.genCounts.push(0);
        } else {
          state.genCounts = new Array(generators.length).fill(0);
        }

        state.upgrades = data.upgrades || { sparks: {}, stabilizers: {} };
        if (!state.upgrades.sparks) state.upgrades.sparks = {};
        if (!state.upgrades.stabilizers) state.upgrades.stabilizers = {};

        state.settings = data.settings || state.settings;
        if (state.settings.autosave === undefined) state.settings.autosave = true;
        if (!state.settings.notation) state.settings.notation = "short";

        return true;
      } catch (e) {
        console.error("Save load failed", e);
        return false;
      }
    }

    // ---------- SETTINGS UI ----------

    function updateSettingsUIFromState() {
      const autosaveCheckbox = document.getElementById("setting_autosave");
      const notationSelect = document.getElementById("notationSelect");
      if (autosaveCheckbox) autosaveCheckbox.checked = !!state.settings.autosave;
      if (notationSelect) notationSelect.value = state.settings.notation || "short";
    }

    function setupSettingsControls() {
      const autosaveCheckbox = document.getElementById("setting_autosave");
      const notationSelect = document.getElementById("notationSelect");
      const btnSaveNow = document.getElementById("btnSaveNow");
      const btnShowIntro = document.getElementById("btnShowIntro");
      const btnFullReset = document.getElementById("btnFullReset");

      autosaveCheckbox.addEventListener("change", () => {
        state.settings.autosave = autosaveCheckbox.checked;
        saveGame();
      });

      notationSelect.addEventListener("change", () => {
        state.settings.notation = notationSelect.value;
        saveGame();
        updateUI();
      });

      btnSaveNow.addEventListener("click", () => {
        saveGame();
        alert("Progress saved to this browser.");
      });

      btnShowIntro.addEventListener("click", () => {
        localStorage.removeItem(INTRO_KEY);
        alert("Intro will show again on next load.");
      });

      btnFullReset.addEventListener("click", () => {
        const sure = confirm(
          "This will erase all progress, upgrades, and settings for Fractured Engine in this browser. Continue?"
        );
        if (!sure) return;
        fullResetProgress();
      });
    }

    function fullResetProgress() {
      localStorage.removeItem(SAVE_KEY);
      localStorage.removeItem(INTRO_KEY);
      location.reload();
    }

    // ---------- BUTTONS, NAV, INTRO ----------

    function setupGeneratorButtons() {
      generators.forEach((gen, index) => {
        const btn = document.getElementById("genBuy_" + gen.id);
        if (!btn) return;
        btn.onclick = () => {
          const cost = genCost(index);
          if (state.sparks >= cost) {
            state.sparks -= cost;
            state.genCounts[index] += 1;
            updateUI();
            saveGame();
          }
        };
      });
    }

    function setupUpgradeButtons() {
      const allBtns = document.querySelectorAll(".upgrade-icon-btn");
      allBtns.forEach(btn => {
        btn.addEventListener("mouseenter", () => {
          const type = btn.dataset.type === "sparks" ? "sparks" : "stabilizers";
          const id = btn.dataset.id;
          const def = getUpgradeDef(type, id);
          if (!def) return;
          selectedUpgrade = { type, def };
          updateUpgradeDetails();
        });

        btn.addEventListener("click", () => {
          const type = btn.dataset.type === "sparks" ? "sparks" : "stabilizers";
          const id = btn.dataset.id;
          const def = getUpgradeDef(type, id);
          if (!def) return;

          selectedUpgrade = { type, def };
          buyUpgrade(type, id);
          updateUI();
        });
      });
    }

    function setupNav() {
      const navButtons = document.querySelectorAll(".nav-btn");
      navButtons.forEach(btn => {
        btn.onclick = () => {
          const tab = btn.dataset.tab;
          showTab(tab);
        };
      });
    }

    function showTab(tab) {
      const sparksTab = document.getElementById("tabSparks");
      const upgradesTab = document.getElementById("tabUpgrades");
      const settingsTab = document.getElementById("tabSettings");

      if (tab === "sparks") {
        sparksTab.classList.remove("hidden");
        upgradesTab.classList.add("hidden");
        settingsTab.classList.add("hidden");
      } else if (tab === "upgrades") {
        sparksTab.classList.add("hidden");
        upgradesTab.classList.remove("hidden");
        settingsTab.classList.add("hidden");
      } else {
        sparksTab.classList.add("hidden");
        upgradesTab.classList.add("hidden");
        settingsTab.classList.remove("hidden");
      }

      const navButtons = document.querySelectorAll(".nav-btn");
      navButtons.forEach(btn => {
        btn.classList.toggle("active", btn.dataset.tab === tab);
      });
    }

    function setupIntroOverlay() {
      const seen = localStorage.getItem(INTRO_KEY);
      const overlay = document.getElementById("introOverlay");
      if (!seen) {
        overlay.classList.remove("hidden");
      } else {
        overlay.classList.add("hidden");
      }
      const introBtn = document.getElementById("introConfirmBtn");
      introBtn.onclick = () => {
        overlay.classList.add("hidden");
        localStorage.setItem(INTRO_KEY, "1");
      };
    }

    // ---------- MAIN LOOP ----------

    let lastTime = performance.now();

    function gameLoop(now) {
      const dt = (now - lastTime) / 1000;
      lastTime = now;

      tick(dt);
      updateUI();

      if (state.settings.autosave && now % 1000 < 50) {
        saveGame();
      }

      requestAnimationFrame(gameLoop);
    }

    // ---------- INIT ----------

    buildGeneratorUI();
    buildUpgradesUI();
    const hadSave = loadGame();
    if (!hadSave) {
      state.sparks = 25;
      state.totalSparksThisRun = 0;
      state.upgrades = { sparks: {}, stabilizers: {} };
      state.settings = { autosave: true, notation: "short" };
    }

    setupGeneratorButtons();
    setupUpgradeButtons();
    setupIntroOverlay();
    setupNav();
    setupSettingsControls();
    updateSettingsUIFromState();
    updateUI();
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
